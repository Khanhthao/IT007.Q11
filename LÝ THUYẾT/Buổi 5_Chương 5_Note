CHƯƠNG 5: ĐỒNG BỘ TIẾN TRÌNH
I. Race Condition:
1. Bài toán Producer với Consumer:
- Gồm 02 tiến trình diễn ra đồng thời với nhau:
+ Producer: liên tục tạo ra hàng hóa -> tăng biến count.
+ Consumer: liên tục bán hàng -> giảm biến count.
---QUIZ---
Câu hỏi: Chọn phát biểu đúng khi nói về thực thi song song và thực thi đồng thời:
A. Ta có 2 tiến trình PA và PB thực thi đồng thời với nhau, nếu CPU core thực thi PA thì PB sẽ vào trạng thái Terminated.
B. Hai hay nhiều tác vụ có thể được thực thi đồng thời chỉ với một core CPU.
C. Nếu hai tác vụ được thực thi đồng thời với nhau thì hệ thống cần có ít hai core CPU.
D. Trong hệ thống có nhiều core CPU, một core CPU chỉ cần phải thực thi một tác vụ
Answer key: B. Hai hay nhiều tác vụ có thể được thực thi đồng thời chỉ với một core CPU.
Chính xác! Khi thực thi đồng thời CPU sẽ được định thời để xử lý các tiến trình khác nhau trong một khoảng thời gian nhất định.
- Thông thường các tiến trình đều sẽ được đặt trong vòng while để thực thi liên tục.
- Khi các tiến trình thực thi đồng thời, ta sẽ KHÔNG biết được các dữ kiện sau:
+ Tiến trình nào thực thi trước?
+ Tiến trình nào thực thi lâu hơn (do giải thuật định thời CPU)?
+ Tiến trình sẽ hết quantum time khi nào?
--- QUIZ ---
Câu 1: Điền vào chỗ trống:
Trong bài toán Producer vs Consumer, biến ... được chia sẻ chung giữa 2 tiến trình và được gọi là dữ liệu được chia sẻ - shared data.
Câu 2: Trong chương trình Prod vs Cons.c, khi chạy chương trình vấn đề gì đã phát sinh?
A. Mảng buffer[in] bị ghi sai vị trí.
B. Tiến trình Producer và Consumer không thực thi xen kẽ nhau làm biến count bị tăng liên tục hoặc giảm liên tục
C. Các giá trị count của tiến trình Producer và Consumer không tăng/giảm theo logic.
D. Tất cả đều đúng.
Answer key: C. Các giá trị count của tiến trình Producer và Consumer không tăng/giảm theo logic.
Câu 3: Trong bài toán Producer vs Consumer, chúng ta sử dụng bounded buffer để lưu các giá trị, đặc điểm của bounded buffer là gì?
A. Các chỉ số được tạo ra ngẫu nhiên
B. Khi mảng đầy, phần tử tiếp theo sẽ được ghi lại vào đầu mảng.
C. Khi ghi giá trị liên tục vào bounded buffer, mảng sẽ bị tràn.
D. Tất cả đều đúng.
Answer key: B. Khi mảng đầy, phần tử tiếp theo sẽ được ghi lại vào đầu mảng.
--- QUIZ ---
Câu hỏi: Giả sử giá trị ban đầu count = 5, mỗi thao tác load, gán, store tốn 1 chu kỳ lệnh. Nếu quantum time = 03 chu kỳ lệnh, biết tiến trình Producer (count++) được thực thi trước Consumer (count--), hấy sắp xếp sự thực thi của các thao tác?
Answer key:
CHU KỲ I: reg1 = count
CHU KỲ II: reg1 = reg1 + 1
CHU KỲ III: count = reg1
CHU KỲ IV: reg2 = count
CHU KỲ V: reg2 = reg2 - 1
CHU KỲ VI: count = reg2
Câu hỏi: Câu hỏi: Giả sử giá trị ban đầu count = 5, mỗi thao tác load, gán, store tốn 1 chu kỳ lệnh. Nếu quantum time = 02 chu kỳ lệnh, biết tiến trình Producer (count++) được thực thi trước Consumer (count--), hấy sắp xếp sự thực thi của các thao tác?
CHU KỲ I: reg1 = count
CHU KỲ II: reg1 = reg1 + 1
CHU KỲ III: reg2 = count
CHU KỲ IV: reg2 = reg2 - 1
CHU KỲ V: count = reg1
CHU KỲ VI: count = reg2
--- QUIZ ---
Câu 1: Thuật ngữ nào sau đây được sử dụng để chỉ ván đề xảy ra bởi việc không đồng bộ tiến trình?
A. Process confliction
B. Data inconsistency
C. Data consistency
D. Data missing
Answer key: B. Data inconsistency
Câu 2: Nhận định sau đúng (True) hay sai (False)?
Giá trị cuối cùng của biến count không phụ thuộc vào việc tiến trình nào thực thi trước.
Answer key: False.
Câu 3: CÁC yếu tố nào sau đây gây ra giá trị biến count của bài toán Producer - Consumer trở nên không nhất quán?
A. Consumer thực hiện các lệnh sau Producer.
B. Biến count được chía sẻ cho 02 tiến trình
C. Các lệnh thao tác lên biến count là đơn nguyên
D. Mã mãy của các lệnh thao tác lên biến count bị thực thi xen kẽ.
Answer key: B, D.
2. Bài toán Cấp phát PID:
- 02 tiến trình P0 và P1 đang tạo tiến trình con bằng cách gọi hàm fork().
- Biến next_available_pid được kernel sử dụng để tạo ra PID cho tiến trình mới.
- Tiến trình con của P0 và P1 đồng thời yêu cầu PID và nhận được kết quả như nhau.
- Cần có cơ chế để ngăn P0 và P1 truy cập biến next_available_pid cùng lúc, để tránh tình trạng một PID được cấp phát cho cả 2 tiến trình.
3. Race condition:
- Race condition là hiện tượng xảy ra khi các tiến trình cùng truy cập đồng thời vào dữ liệu được chia sẻ. Kết quả cuối cùng sẽ phụ thuộc vào thứ tự thực thi của các tiến trình đang chạy đồng thời với nhau.
- Trong bài toán Producer vs Consumer dữ liệu được chia sẻ là biến count bị tác động đồng thời bởi cả 2 tiến trình Producer và Consumer. Trong bài toán cấp phát PID, dữ liệu được chia sẻ là biến next_available_pid bị tranh giành bởi tiến trình thực thi đồng thời là P0 và P1.
- Race condition có thể dẫn đến việc dữ liệu bị sai và không nhất quán (inconsistency).
- Để dữ liệu chia sẻ được nhất quán, cần đảm bảo sao cho tại mỗi thời điểm chỉ có 1 tiến trình được thao tác lên dữ liệu chía sẻ. Do đó cần có cơ chế dồng bộ hoạt động của các tiến trình này.
--- QUIZ ---
Câu 1: Chọn phát biểu đúng khi nói về race condition: 
A. Race condition là hiện tượng xảy ra khi các tiến trình không thể truy cập vào dữ liệu được chia sẻ cùng một lúc.
B. Race condition là hiện tượng xảy ra khi các tiến trình chỉ truy cập vào dữ liệu được chia sẻ một cách tuần tự.
C. Race condition là hiện tượng xảy ra khi dữ liệu chia sẻ không thay đổi dưới tác động của các tiến trình.
D. Race condition là hiện tượng xảy ra khi các tiến trình cùng truy cập đồng thời vào dữ liệu được chia sẻ, kết quả cuối cùng phụ thuộc vào thứ tự thực thi của các tiến trình.
Answer key: D. Race condition là hiện tượng xảy ra khi các tiến trình cùng truy cập đồng thời vào dữ liệu được chia sẻ, kết quả cuối cùng phụ thuộc vào thứ tự thực thi của các tiến trình.
Câu 2: Race condition có thể dẫn đến:
A. Dữ liệu được cập nhật chính xác và nhất quán
B. Dữ liệu bị sai và không nhất quán
C. Các tiến trình không thể hoạt động đồng thời
D. Dữ liệu được chia sẻ không bị ảnh hưởng bởi race condition
Answer key: B. Dữ liệu bị sai và không nhất quán
II. Vấn đề vùng tranh chấp: 
- Xem xét hệ thông có n tiến trình {P0, P1,....Pn-1)
- Mỗi tiến trình có một vùng tranh chấp là một đoạn code:
+ Thực hiện việc thay đổi giá trị của dữ liệu được chia sẻ, cập nhật bảng, ghi file,...
+ Khi một tiến trình đang thực hiện vùng tranh chấp của mình thì các tiến trình khác KHÔNG được thực hiện vùng tranh cháp của chúng.
- Vấn đề vùng tranh chấp chính là thiết kế cách thức xử lý các vấn đề trên.
- Mỗi tiến trình phải yêu cầu để được phép tiến vào vùng tranh chấp của mình thông qua entry section, sau đó thực thi vùng tranh chấp - critical section, rối tiến đến exit section, và sau cùng là remainder section.
Đoạn code: 
while (1){
  entry section
    critical section
  exit section
    remainder section
}
3. Yêu cầu dành cho lời giải bài toán giải quyết tranh chấp:
- Lời giải cho bài toán vùng tranh chấp phải đảm bảo 3 yêu cầu sau:
+ (1) Mutual exclusion (loại trừ tương hỗ): Khi một process P đang thực thi trong vùng tranh chấp (CS) của nó thì không có process Q nào khác đang thực thi trong CS của Q.
+ (2) Progress (tính tiến triển): Một tiến trình tạm dừng bên ngoài vùng tranh chấp không được ngăn cản các tiến trình khác vào vùng tranh chấp.
+ (3) Bounded waiting (chờ đợi giới hạn): Mỗi process chỉ phải chờ để được vào vùng tranh chấp trong một khoảng thời gian có hạn định nào đó. Không xảy ra tình trạng đói tài nguyên (starvation).
--- QUIZ ---
Câu 1: Mutual exclusion (loại trừ tương hỗ) trong bài toán vùng tranh chấp đảm bảo điều gì?
A. Tiến trình chỉ được phép vào vùng tranh chấp sau khi đã thực thi trong vùng khác.
B. Mỗi tiến trình chỉ được phép thực thi trong vùng tranh chấp của nó.
C. Không có tiến trình nào được ngăn cản vào vùng tranh chấp
D. Không có tiến trình nào cũng được thực thi trong vùng tranh chấp.
Answer key: D. Không có tiến trình nào cũng được thực thi trong vùng tranh chấp.
Câu 2: Progress (tính tiến triển) trong bài toán vùng tranh chấp đảm bảo điều gì?
A. Tiến trình không bị ngăn cản vào vùng tranh chấp.
B. Tiến trình không bị chặn trong vùng tranh chấp khi không có tiến trình khác thực thi vùng tranh chấp.
C. Mỗi tiến trình phải chờ đợi trong vùng tranh chấp.
D. Tiến trình chỉ được thực thi trong vùng tranh chấp.
Answer key: B. Tiến trình không bị chặn trong vùng tranh chấp khi không có tiến trình khác thực thi vùng tranh chấp.
Câu 3: Bounded waiting (chờ đợi giới hạn) trong bài toán vùng tranh chấp đảm bảo điều gì?
A. Tiến trình chỉ được phép vào vùng tranh chấp sau khi đã thực thi trong vùng khác trong một khoảng thời gian xác định.
B. Tiến trình không bị ngăn cản vào vùng tranh chấp.
C. Mỗi tiến trình chỉ phải chờ đợi trong một khoảng thời gian xác định để vào vùng tranh chấp.
D. Mỗi tiến trình phải chờ đợi vô thời hạn để vào vùng tranh chấp.
Answer key: C. Mỗi tiến trình chỉ phải chờ đợi trong một khoảng thời gian xác định để vào vùng tranh chấp.
Câu 4: Chọn CÁC phát biểu đúng khi nói về starvation và deadlock?
A. Deadlock thường xảy ra khi hai hay nhiều tiến trình chờ đợi lẫn nhau các điều kiện nào đó
B. Deadlock và starvation đều làm cho tiến trình bị chờ vô hạn định
C. Starvation xảy ra khi tiến trình bị ngăn cản nhận tài nguyên, từ đó dẫn đến việc tiến trình không thể thực thi
D. Deadlock và starvation đều bị gây ra bởi hiện tượng tiến trình có độ ưu tiên thấp bị các tiến trình có độ ưu tiên cao trưng dụng tài nguyên
Answer key: A, B, C
IV. Các giải pháp dựa trên ngắt (giải pháp phần mềm):
1. Giải pháp phần mềm 1:
- Giải pháp dành cho 2 tiến trình
- Giả sử 2 lệnh hợp ngữ load và store là 2 thao tác đơn nguyên (không thể bị cắt ngang).
- 2 tiến trình cũng chia sẻ một biến turn: int turn;
- Biến turn có tác dụng chỉ ra tiến trình nào tới lượt để vào vùng tranh chấp.
- Giá trị của turn sẽ được khởi tạo là i.
- Mutal exclusion được đảm bảo:
Pi chỉ được phép vào vùng tranh chấp khi: turn = i và turn không thể vừa bằng i vừa bằng j được (nếu i = 0 và j = 1 thì turn không thể vừa bằng 0, vừa bằng 1)
- Kiểm tra Progress -> Không đảm bảo.
- Kiểm tra Bounded Waiting -> Không đảm bảo.
--- QUIZ ---
Câu 1: Trong giải pháp phần mềm số 1, CÁC yêu cầu nào không được đáp ứng?
A. Progress và Bounded waiting
B. Mutual Exclusion và Bounded waiting
C. Mutual Exclusion và Progress
D. Mutual Exclusion, Bounded waiting, và Progress
Answer key: A. Progress và Bounded waiting
Câu 2: Điền vào chỗ trống:
Để hiện thực giải pháp phần mềm số 1, các thao tác load và store phải là những thao tác ....
Answer key: đơn nguyên.
2. Giải pháp Peterson:
- Giải pháp dành cho 2 tiến trình.
- Giả sử 2 lệnh hợp ngữ load và store là 2 thao tác đơn nguyên (không thể bị cắt ngang).
- 2 tiến trình cùng chia sẻ 2 biến:
  int turn;
  boolean flag[2];
- Biến turn có tác dụng chỉ ra tiến trình nào tới lượt để vào vùng tranh chấp.
- Mảng flag[] được dùng để xác định liệu tiến trình đã sẵn sàng để vào vùng tranh chấp chưa
  flag[i]= true; ám chỉ là Pi đã sẵn sàng để vào vùng tranh chấp.
- Mutual exclusion được đảm bảo:
Pi chỉ được phép vào vùng tranh chấp khi hoặc flag[j] = false hoặc turn = i và turn không thể vừa bằng i, vừa bằng j được (nếu i=0 và j=1 thì turn không thể vừa bằng 0, vừa bằng 1).
- P0 và P1 cùng tiến vào vùng tranh chấp, có nghĩa 2 tiến trình đã phải thực hiện entry section trước đó.
- Kiểm tra Progress -> Đảm bảo.
- Kiểm tra Bounded Waiting -> Đảm bảo:
+ P1 phải chờ tối đa 1 lần P0 vào vùng tranh chấp.
+ CS thường rất nhỏ nên thời gian chờ đợi sẽ không dài.
--- QUIZ ---
Câu 1: Điền vào chỗ trống:
Trong giải thuật Peterson, nếu muốn vào vùng tranh chấp, tiến trình P1 phải chờ tối đa là ... lần vào P0 vào CS.
Answer key: 1
Câu 2: Giải thuật Peterson thỏa mãn CÁC yêu cầu nào dành cho lời giải bài toán đồng bộ?
A. Không yêu cầu nào cả
B. Bounded Waiting
C. Mutual Exclusion
D, Progress.
Answer key: B, C, D.
Câu 3: Phát biểu nào sau đây là sai khi nói về giải thuật Peterson?
A. Biến turn đóng vai trò kiểm tra lượt của tiến trình và cờ flag[] thể hiện sự sẵn sàng của tiến trình khi muốn tiến vào vùng tranh chấp.
B. Giải thuật Peterson có thể áp dụng cho n tiến trình.
C. Giải thuật Peterson có thể gây ra hiện tượng starvation.
D. Giải thuật Peterson có thể gây ra hiện tượng deadlock.
Answer key: B. Giải thuật Peterson có thể áp dụng cho n tiến trình.
3. Giải thuật Peterson và kiến trúc hiện đại:
- Để cải thiện hiệu suất, vi xử lý và/hoặc trình biên dịch sẽ sắp xếp lại các thao tác mà độc lập với nhau.
- Việc hiểu vì sao giải pháp Peterson không hoạt động trên kiến trúc hiện đại sẽ giúp sinh viên hiểu rõ hơn về race condition.
- Với các tiến trình đơn tiểu trình thì việc thực hiện các lệnh sẽ không có gì thay đổi.
- Với các tiến trình đa tiểu trình, việc sắp xếp lại các thao tác có thể dẫn đến kết quả không nhất quán hoặc không dự đoán được.
- Có hai tiến trình cùng chia sẻ dữ liệu:
boolean flag = false;
int x = 0;
- Thread1 thực hiện:
while (!flag);
print x;
- Thread2 thực hiện:
x = 100;
flag = true;
- Tuy nhiên, bởi vì biến flag và biến x là độc lập với nhau nên các thao tác:
flag = true;
x = 100;
có thể bị sắp xếp lại thứ tự thực hiện.
- Trong trường hợp này, kết quả có thể được in ra là 0. 
- Xét lại giải pháp Peterson:
+ Việc gán flag[] và turn bị sắp xếp lại thứ tự thực thi
+ P0 và P1 cùng vào CS. 
+ Để đảm bảo giải pháp Peterson hoạt động chính xác trên kiến trúc máy tính hiện đại, ta phải sử dụng Memory Barrier.
--- QUIZ ---
Câu 1: Cơ chế nào sau đây được đề xuất để có thể thực hiện giải pháp Peterson trên kiến trúc hiện đại?
A. Signaling
B. Memory Barrier
C. Exception handling
D. Interrupts.
Answer key: B. Memory Barrier.
Câu 2: Chọn phát biểu sai khi phát biểu về kiến trúc hiện đại?
A. Vi xử lý/trình biên dịch sắp xếp lại tất cả thao tác trong mã nguồn để gia tăng hiệu suất xử lý
B. Các tiến trình đơn tiểu trình không bị ảnh hưởng bởi viêc sắp xếp lại các thao tác
C. Các kết quả không dự đoán được có thể xuất hiện trên các tiến trình đa tiểu trình
D. Các thao tác độc lập với nhau có khả năng bị sắp xếp lại thứ tự thực hiện
Answer key: A. Vi xử lý/trình biên dịch sắp xếp lại tất cả thao tác trong mã nguồn để gia tăng hiệu suất xử lý
V. Memory Barrier:
- Memory model trong hệ điều hành là mô hình hoạt động của bộ nhớ trong hệ thống, bao gồm cách thức quản lý và truy xuất đến các vùng nhớ được cấp phát cho các tiến trình và luồng trong hệ thống. Memory model định nghĩa các quy tắc và ràng buộc cho việc sử dụng bộ nhớ, đám bảo tính đúng đắn, an toàn và hiệu quả của các hoạt động trên bộ nhớ.
- Hai mô hình bộ nhớ phổ biến bao gồm:
+ Mô hình bộ nhớ được sắp xếp mạnh (strongly ordered memory model); các thay đổi bộ nhớ trên một bộ xử lý sẽ được các bộ xử lý khác biết ngay lập tức.
+ Mô hình bộ nhớ được sắp xếp yếu (weakly ordered memory model): các thay đổi bộ nhớ trên một bộ xử lý CÓ THỂ sẽ KHÔNG được các bộ xử lý khác biết ngay lập tức.
- Memory barrier: là một chỉ thị (instruction) mà bắt buộc mọi thay đổi trong bộ nhớ phải được truyền tải (hiện thị) đến tất cả bộ xử lý khác.
- Chỉ thị Memory Barrier: 
+ Khi một chỉ thị được thực hiện, hệ thống sẽ đảm bảo là tất cả thao tác load (nạp dữ liệu) và store (ghi dữ liệu) đều đã được hoàn thành trước khi các thao tác load và store sau đó được thực hiện.
+ Do đó, kể cả khi các lệnh bị sắp xếp lại, memory barrier bảo đảm rằng các thao tác ghi dữ liệu đều đã được hoàn thành trong bộ nhớ và được truyền tải đến các bộ xử lý khác trước khi các thao tác nạp dữ liệu hoặc ghi dữ liệu được thực thi trong tương lai.
--- QUIZ ---
Câu 1: Mục đích chính của Memory Barrier là gì?
A. Đảm bảo thứ tự thực thi các câu lệnh.
B. Ngăn chặn truy cập không đồng bộ vào bộ nhớ.
C. Loại bỏ các lỗi thời gian thực thi.
D. Tăng hiệu suất thực thi của chương trình.
Answer key: A. Đảm bảo thứ tự thực thi các câu lệnh.
Câu 2: Memory Barrier được chia thành các loại nào?
A. Atomic barrier và Non-atomic barrier
B. Exclusive barrier và Inclusive barrier
C. Static ordered memory model và Dynamic ordered memory model
D. Strongly ordered memory model và Weakly ordered memory model
Answer key: D. Strongly ordered memory model và Weakly ordered memory model
Câu 3: Nhận định sau đúng (True) hay sai (False): Sử dụng memory barrier có thể là giảm hiệu suất của chương trình?
A. Đúng
B. Sai
Answer key: A. Đúng
VI. Mutex Locks:
1. Định nghĩa Mutex Locks:
- Nếu xem vùng tranh chấp là 1 căn phòng thì Mutex lock là ổ khóa để khóa phòng để làm việc.
- Cung cấp 2 thao tác: gọi acquire lock để yêu cầu khóa r tiến vào vùng tranh chấp, gọi release lock để tiến ra ngoài.
- Khi thực hiện thao tác acquire nma không available thì nó chờ, chờ thao tác đó thì ko còn wait nữa.
- Thao tác gọi là acquire() hoặc release () phải được thực hiện đơn nguyên
-> Có thể được hiện thực thông qua lệnh phần cứng đơn nguyên như compare_and_swap.
- Nếu busy waiting thì vẫn lãng phí CPU.
2. Mutex locks không busy waiting trong mutex locks
- Ta tạm thời đặt tiến tình vào trạng thái ngủ khi khóa bị khóa, và sau đó đánh thức tiến trình dậy khi khóa được mở.
- Hệ điều hành cần cung cấp 2 thao tác: 
+ Block: tạm dừng và đặt tiến trình gọi thao tác này vào trong hàng đợi - trạng thái ngủ.
+ Wakeup: xóa một tiến trình ra khỏi hàng dợi và đặt lại vào trong hàng đợi sẵn sàng - đánh thức. 
- Tiến trình P muốn vào CS:
+ Nếu khóa Mutex đang mở: tiến trình khóa lại và tiến vào CS.
+ Nếu khóa mutex đang khóa: tiến trình P bị block và vào trạng thái ngủ.
- Tiến trình P sau khi hoàn thành CS:
+ Mở khóa Mutex.
+ Đánh thức tiến trình Q (nếu có) đang ngủ trong hàng chờ.
--- QUIZ ---
Câu hỏi: Mutex lock đảm bảo loại trừ tương hỗ bằng cách nào?
A. Các tiến trình phải vào trạng thái ngủ trước khi vào vùng tranh chấp, tiến trình nào thức dậy trước sẽ được tiến vào vùng tranh chấp trước
B. Tiến trình bị block bởi mutex sẽ được đánh thức sau một quãng thời thời gian q, sau đó trưng dụng CPU của tiến trình đang thực thi vùng tranh chấp trước đó
C. Đảm bảo khoá mutex chỉ có thể được khoá bởi một tiến trình tại mọi thời điểm, các tiến trình yêu cầu sau sẽ bị block
Answer key: C. Đảm bảo khoá mutex chỉ có thể được khoá bởi một tiến trình tại mọi thời điểm, các tiến trình yêu cầu sau sẽ bị block
3. Cách sử dụng Mutex locks: 
- Lưu ý: 
+ Mutex lock thường sẽ được khai báo toàn cục và được khởi tạo trong hàm main.
+ Cần phải xác định đúng vùng tranh chấp trước khi thực hiện các thao tác trên khóa mutex (acquire và release):
- Khai báo và khởi tạo mutex -> Tiến trình/Tiểu trình yêu cầu khóa Mutex - acquire() để thực hiện CS -> Tại một thời điểm chỉ có một tiến trình/ tiểu trình thành công khóa mutex và thực hiện CS -> Tiến trình mở khóa mutex - release () sau khi rời CS -> Hủy khóa Mutex.
