CHƯƠNG IV: ĐỊNH THỜI CPU
I. Các khái niệm cơ bản về định thời:
- Trong các hệ thống đa nhiệm (multitasking), đơn vị xử lý:
+ Cho phép thực thi đồng thời nhiều chương trình để làm tăng hiệu suất hệ thống (Cho phép nhiều chương trình được nạp vào bộ nhớ).
+ Tại mỗi thời điểm, chỉ có một tiến trình được thực thi.
- Cần giải quyết vấn đề phân chia, lựa chọn tiến trình thực thi để đạt được hiệu quả cao nhất.
- Cần có những phương pháp chọn lựa phù hợp.
--> Định thời là chiến lược lựa chọn tiến trình phù hợp để được thực thi sao cho đạt được hiệu quả cao nhất.
- Chu kỳ CPU/IO:
+ Service time  là thời gian một tiến trình cần CPU trong một chu kỳ CPU - I/O (hay còn gọi là burst time).
+ Tiến trình có service time lớn được gọi là các tiến trình hướng CPU (CPU-bound process).
- Tiến trình hướng CPU (CPU-bound):
+ Tiến trình yêu cầu thời gian thực thi trên CPU nhiều.
+ Thời gian hoàn thành chương trình phụ thuộc vào tốc độ thực thi của CPU. 
- Tiến trình hướng I/0 (I/O-bound):
+ Tiến trình yêu cầu thời gian thực thi trên ngoại vi nhiều hơn.
+ Thời gian hoàn thành chương trình phụ thuộc chu kỳ đợi cho các thao tác nhập/xuất.
--- QUIZ ---
Câu 1: NHỮNG phát biểu nào sau đây là đúng?
A. Việc định thời tiến trình cần đảm bảo sao cho các tiến trình hướng I/O tương tác tốt với người dùng.
B. Tiến trình hướng I/O là tiến trình dành phần lớn thời gian để thực hiện việc đọc dữ liệu từ bộ nhớ.
C. Việc định thời tiến trình cần ưu tiên cho các tiến trình hướng CPU để tận dụng tốt nhân xử lý.
D. Tiến trình hướng CPU là tiến trình phần lớn thời gian để thực hiện các thao tác tính toán.
Answer key: A, D.
Câu 2: Chọn phát biểu sai trong các phát biểu sau đây?
A. Khi thực thi, tiến trình sẽ thay đổi qua lại giữa 2 trạng thái là CPU Burst và I/O Burst.
B. Trong hệ thống đa chương, khi tiến trình thực hiện xử lý I/O đồng nghĩa với việc tiến trình từ bỏ CPU và tiến trình khác có thể được sử dụng CPU và thực thi.
C. Thông thường, tiến trình sẽ bắt đầu bằng trạng thái I/O Burst và kết thúc bằng CPU Burst.
D. Trong hệ thống đa chương, hệ điều hành cần lựa chọn tiến trình nào được nhận CPU và thực thi thông qua việc định thời.
Answer key: C. Thông thường, tiến trình sẽ bắt đầu bằng trạng thái I/O Burst và kết thúc bằng CPU Burst.
Câu 3: Phát biểu sau Đúng hay Sai:
Theo đo lường trên quy mô lớn, thông thường tần suất tiến trình sử dụng CPU trong thời gian ngắn sẽ nhiều hơn rất nhiều lần tần suất tiến trình sử dụng CPU trong thời gian dài.
A. True 
B. False
Answer key: A. True.
II. Các loại định thời:
--- QUIZ ---
Câu hỏi: Trong các bộ định thời, bộ định thời nào ảnh hưởng đến mức độ đa chương của hệ thống:
A. Bộ định thời ngắn
B. Bộ định thời trung gian
C. Bộ định thời dài
Answer key: B, C.
1. Định thời dài (Long-term Scheduling):
- Xác định chương trình nào được chấp nhận nạp vào hệ thống để thực thi.
--> Điều khiển mức độ đa chương của hệ thống.
- Định thời dài thường cố gắng duy trì xen lẫn giữa tiến trình hướng CPU (CPU-bound process) và tiến trình I/O (I/O-bound process).
2. Định thời vừa (Medium-term Scheduling):
- Định thời vừa quyết định tiến trình nào được đưa vào (swap in) và đưa ra khỏi (swap out) bộ nhớ chính trong quá trình thực thi của hệ thống.
- Được thực hiện bởi thành phần quản lý bộ nhớ.
3. Định thời ngắn (Short-term Scheduling):
- Còn được gọi là định thời CPU.
- Xác định tiến trình nào trong hàng đợi sẵn sàng (ready queue) sẽ được chiếm CPU để thực thi kế tiếp.
- Đối với hệ thống hỗ trợ nhân đa luồng (multithreaded kernel), việc định thời CPU là do OS chọn kernel thread được chiếm CPU.
- Bộ định thời ngắn được gọi khi có một trong các sự kiện/interrupt sau xảy ra:
+ Ngắt thời gian (clock interrupt).
+ Ngắt ngoại vi (I/O interrupt).
+ Lời gọi hệ thống (operating system call).
+ Tín hiệu đồng bộ hóa.
- Bộ định thời sẽ chuyển quyền điều khiển CPU về cho tiến trình được chọn.
- Qúa trình chuyển đổi bao gồm:
+ Chuyển ngữ cảnh (sử dụng thông tin ngữ cảnh trong PCB).
+ Chuyển chế độ người dùng.
+ Nhảy đến vị trị thích hợp trong chương trình ứng dụng để khởi động lại chương trình (sử dụng thông tin địa chỉ tại program counter trong PCB).
- Công việc này gây ra phí tổn:
+ Dispatch latency: thời gian mà bộ định thời dừng một tiến trình và khởi động một tiến trình khác.
--- QUIZ ---
Câu 1: Bộ định thời dài thực hiện CÁC công việc nào sau đây?
A. Quyết định tiến trình nào phải tạm thời di chuyển ra bộ nhớ thứ cấp.
B. Cố gắng duy trì xen lẫn giữa CPU-bound process và I/O-bound process.
C. Quyết định tiến trình nào được chuyển trạng thái từ Ready thành Running.
D. Quyết định nạp tiến trình vào trong bộ nhớ chính.
Answer key: B, D.
Câu 2: Bộ định thời trung gian thực hiện việc di chuyển tiến trình vào/ra bộ nhớ chính và bộ nhớ thứ cấp nhờ cơ chế nào sau đây?
A. Push và Pop
B. Swap in và swap out
C. Turn in và Turn out
D. Remove and Recover.
Answer key: B. Swap in và Swap out
Câu 3: Trong các loại bộ định thời, loại nào thực hiện "định thời CPU"?
A. Bộ định thời trung gian
B. Bộ định thời ngắn
C. Bộ định thời dài
Answer key: B. Bộ định thời ngắn
III. Các tiêu chuẩn định thời CPU:
- Hướng người dùng (user-oriented):
+ Thời gian đáp ứng (Response time): khoảng thời gian từ lúc tiến trình gửi yêu cầu thực thi đến khi yêu cầu được đáp ứng lần đầu tiên (trong các hẹ thống time-sharing, interactive system) --> cực tiểu.
+ Thời gian hoàn thành (Turnaround time): khoảng thời gian từ lúc một tiến trình được nạp vào hệ thống đến khi tiến trình đó kết thúc --> cực tiểu.
+ Thời gian đợi (Waiting time): tổng thời gian một tiến trình đợi trong ready queue --> cực tiểu.
- Cách xác định các thông số định thời: 
Giả sử: 
+ Qúa trình thực thi một tiến trình P gầm nhiều phần.
+ r là thời điểm xuất hiện của P trong hệ thống.
+ t0 là thời điểm P được thực thi lần đầu tiên.
+ f là thời điểm tiến trình P hoàn thành việc thực thi (Finishing Time).
Gọi R, F, và W lần lượt là thời gian đáp ứng, thời gian hoàn thành và thời gian đợi của tiến trình P.
Khi đó: R = t0-r, F=f-r, W=f-r-E= F-E
Trong đó: E là thời gian yêu cầu của P để thực thi trên CPU (hay CPU Burst):
E=E1+E2+E3.
- Hướng hệ thống (System-oriented):
+ Hiệu năng sử dụng CPU (processor utilization): định thời sao cho CPU càng bận càng tốt --> cực đại.
+ Tính công bằng (fairness): tất cả tiến trình phải được đối xử như nhau.
+ Thông lượng (throughout): số tiến trình hoàn tất công việc trong một đơn vị thời gian --> cực đại.
--- QUIZ ----
Câu 1: Trong các tiêu chuẩn sau, đâu là tiêu chuẩn định thời theo hướng hệ thống?
A. Số tiến trình hoàn thành trong một đơn vụ thời gian là nhiều nhất.
B. Thời gian hoàn thành ngắn nhất
C. Các tiến trình được phân chia thời gian sử dụng CPU công bằng
D. CPU bận rộn nhất
E. Số tiến trình hoàn thành trong một đơn vị thời gian là ít nhất
F. CPU trống nhiều nhất.
G. Thời gian chờ ngắn nhất
H. Thời gian đáp ứng ngắn nhất
Answer key: A, C, D.
Câu 2: Trong các tiêu chuẩn sau, đâu là tiêu chuẩn định thời theo hướng người dùng?
A. Thời gian hoàn thành ngắn nhất.
B. Số tiến trình hoàn thành trong một đơn vị thời gian là nhiều nhất
C. CPU trống nhiều nhất
D. Thời gian đáp ứng ngắn nhất
E. Thời gian chờ ngắn nhất
F. CPU bận rộn nhất
G. Các tiến trình được phân chia thời gian sử dụng CPU công bằng nhất
H. Số tiến trình hoàn thành trong một đơn vị thời gian là ít nhất.
Answer key: A, D, E
IV. Các giải thuật định thời:
1. Giải thuật định thời:
Một giải thuật định thời thông thường bao gồm 2 yếu tố:
- Hàm chọn lựa (selection function): mô tả cách thức (căn cứ) để chọn tiến trình nào trong ready queue được thực thi (Các hàm chọn lựa thường được xây dựng dựa trên độ ưu tiên, yêu cầu về tài nguyên, đặc điểm thực thi của tiến trình,...)
- Chế độ quyết định (decision mode): quyết định thời điểm thực hiện hàm chọn lựa để định thời.
- Các chế độ quyết định:
+ Không trưng dụng (Non-preemptive):
. Khi ở trạng thái running, tiến trình sẽ thực thi cho đến khi kết thúc hoặc bị ngắt (blocked) do yêu cầu I/O.
+ Trưng dụng (Preemptive):
. Tiến trình đang thực thi (ở trạng thái running) có thể bị ngắt giữa chừng và chuyển về trạng thái ready.
. Chi phí cao hơn chế độ không trưng dụng nhưng đanh đổi lại bằng thời gian đáp ứng tốt hơn vì không có trường hợp một tiến trình độc chiếm CPU quá lâu.
- Thời điểm thực thi hàm chọn lựa:
+ Hàm chọn lựa được thực thi vào các thời điểm sau:
(1): Có tiến trình chuyển từ trạng thái running sang waiting.
(2): Có tiến trình chuyển từ trạng thái running sang ready.
(3): Có tiến trình chuyển từ trạng thái waiting, new sang ready.
(4): Kết thúc thực thi của một tiến trình
-> (1) và (4) không cần lựa chọn loại định thời, (2) và (3) thì cần:
. Việc thực thi hàm chọn lựa trong trường hợp (1) và (4) không phụ thuộc vào loại giải thuật định thời và thường áp dụng chế độ trưng dụng.
. Ngược lại, trường hợp (2) và (3) phụ thuộc vào loại giải thuật định thời và thường áp dụng chế độ trưng dụng.
--- QUIZ ---
Câu hỏi: Chọn các phát biểu ĐÚNG khi nói về các chế độ quyết định?
A. Chế độ không trưng dụng thường sẽ yêu cầu ít chuyển ngữ cảnh hơn chế độ trưng dụng.
B. Việc áp dụng chế độ trưng dụng sẽ đòi hỏi chi phí tính toán cao hơn chế độ không trưng dụng
C. Tiến trình có thể bị thu hồi CPU khi đang thực thi nếu áp dụng cơ chế không trưng dụng
D. Nếu sử dụng cơ chế trưng dụng, tiến trình sẽ được đảm bảo được thực thi mà không bị thu lại CPU giữa chừng.
- Các giải thuật định thời:
+ First-Come, First-Served (FCFS).
+ Shortest Job First (SJK)
+ Shortest Remaining Time First (SRTF)....
--- QUIZ ---
Câu 1: Nhận định sau Đúng hay Sai?
Khi sử dụng ché độ không trưng dụng, nếu tiến trình không thực hiện I/O thời gian chờ cũng chính là thời gian đáp ứng.
A. True 
B. False
Answer key: Chính xác! Do trong chế độ không trưng dụng, tiến trình chỉ phải thực hiện chờ đợi khi chưa được nhận CPU để thực thi. Một khi đã được nhận CPU, tiến trình sẽ thực thi đế khi kết thúc mà không phải chờ đợi thêm lần nào nữa (không tính trường hợp xử lý I/O))
2. Giải thuật First-come, First-Served (FCFS):
- Hàm lựa chọn:
+ Tiến trình nào yêu cầu CPU trước sẽ được cấp phát CPU trước.
+ Tiến trình sẽ thực thi đến khi kết thúc hoặc bị block do I/O.
- Chế độ quyết định: không trưng dụng (non-preemptive).
- Hiện thực: sử dụng hàng đợi FIFO (FIFO queues):
+ Tiến trình mới xuất hiện được thêm vào cuối hàng đợi
- Đối với giải thuật First-Comes-First-Served, độ ưu tiên được sử dụng để lựa chọn tiến trình nhận CPU chính là Arrival Time. Trong đó, giá trị của đại lượng càng lớn thì sẽ càng được xếp về phía cuối hàng đợi và ngược lại.
- Thời gian đáp ứng (Response TIme) = Start - Arrival Time/ Tổng tiến trình
- Thời gian hoàn thành (Turnaround Time) = Finish - Arrival Time/ Tổng tiến trình
- Thời gian chờ (Waiting Time) = Turnaround - Burst Time 
- Đối với giải thuật không trưng dụng, thời gian chờ bằng thời gian đáp ứng.
3. Shortest-Job-First (SJF):
- Hàm chọn lựa: tiến trình có thời gian yêu cầu thực thi (CPU burst) ngắn nhất sẽ được chọn.
+ Khi CPU trống, OS sẽ chọn tiến trình có CPU Burst ngắn nhất để được thực thi tiếp theo.
+ Giải thuật này sử dụng chiều dài thời gian thực thi của tiến trình làm căn cứ để chọn lựa.
- SJF có thể được hiện thực với cả 2 chế độ quyết định: trưng dụng và không trưng dụng.
- SJK ở chế độ không trưng dụng:
+ Hàm chọn lựa được thực thi khi CPU trống.
+ Khi tiến trình được cấp CPU thì sẽ được thực thi cho đến khi kết thúc.
+ Khi một tiến trình kết thúc, một tiến trình đã sẵn sàng khác có thời gian thực thi ngắn nhất sẽ được chọn.
- SJK ở chế độ trưng dụng: 
+ Hàm chọn lựa được thực thi khi có tiến trình mới xuất hiện hoặc có tiến trình kết thúc.
+ Khi có tiến trình mới xuất hiện với CPU-burst nhỏ hơn thời gian yêu cầu còn lại (remaining time) của tiến trình đang thực thi, tiến trình mới sẽ được chọn và tiến trình đang thực thi sẽ bị dừng lại.
+ Khi một tiến trình kết thúc, một tiến trình khác có CPU-Burst (hoặc thời gian yêu cầu còn lại) nhỏ nhất sẽ được chọn tiếp theo.
+ SJK ở chế độ trưng dụng còn được gọi là Shortest-Remaining-Time-First (SRTF).
+ SRTF là tối ưu về thời gian đợi: có thời gian chờ đợi trung bình ngắn nhất với mội tập tiến trình cho trước.
- Nhận xét về giải thuật SJF: 
+ Có thể xảy ra tình trạng "đói" tài nguyên đối với các tiến trình có CPU-burst lớn nếu có nhiều tiến trình CPU-burst nhỏ (liên tục) xuất hiên trong hệ thống.
+ Cơ chế không trưng dụng không phù hợp cho hệ thống time sharing (interactive).
+ Giải thuật SJF ngầm định rằng độ ưu tiên được xác định dựa theo độ dài CPU-burst.
-> Các tiến trình hướng CPU (CPU-Bound) có độ ưu tiên thấp hơn so với tiến trình hướng I/O (I/O-bound).
-> Tuy nhiên,khi một tiến trình hướng CPU được thực thi thì nó độc chiếm CPU cho đến khi kết thúc.
- Ưu điểm: SJF tối ưu trong việc giảm thời gian đợi trung bình.
- Hạn chế: Cần phải ước lượng thời gian cần CPU tiếp theo của tiến trình.
- Thời gian sử dụng CPU chính là độ dài của CPU Burst:
+ Trung bình tất cả các CPU Burst đo được trong quá khứ.
+ Nhưng thông thường những CPU Burst càng mới càng phản ánh đúng hành vi của tiến trình trong tương lai.
- Một kỹ thuật thường dùng là sử dụng trung bình hàm mũ.
4. Giải thuật Priority Scheduling:
- Mỗi tiến trình sẽ được gán một độ ưu tiên (thường biểu diễn bởi một con số).
- CPU sẽ được cấp cho tiến trình có độ ưu tiên cao nhất theo các giá trị số được gán (có thể theo thứ tự tăng dần hay giảm dần).
- Định thời sử dụng độ ưu tiên có thể: Preemptive, Non-preemptive.
- Cách gán độ ưu tiên cho tiến trình:
+ SJF là một giải thuật định thời sử dụng độ ưu tiên được xác định dựa vào thời gian sử dụng CPU (giá trị được ước lượng).
+ Ngoài ra, việc gán độ ưu tiên còn có thể dựa vào:
. Yêu cầu về bộ nhớ.
. Số lượng file được mở.
. Tỉ lệ thời gian dùng cho I/O trên thời gian sử dụng CPU. 
. Các yêu cầu bên ngoài ví dụ như: số tiền người dùng trả khi thực thi công việc.
- Hạn chế:
+ Vấn đề trì hoãn vô hạn định: tiến trình có độ ưu tiên thấp có thể không bao giờ được thực thi (do có những tiến trình độ ưu tiên cao hơn liên tục xuất hiện).
- Giải pháp: làm mới (aging) - độ ưu tiên của tiến trình sẽ tăng theo thời gian.
5. Giải thuật Round Robin:
- Mỗi tiến trình nhận được một đơn vị thời gian CPU (time slice, quantum time) để thực thi. Thông thường khoảng thời gian này nhỏ, từ 10-100 ms.
- Sau khoảng thời gian đó, tiến trình bị đoạt quyền và trở về cuối ready queue.
- Gọi n là số lượng tiến trình trong ready queue và q là khoảng thời gian đơn vụ mà CPU được cấp phát cho tiến trình (quantum time), khi đó, không có tiến trình nào phải chờ đợi quá (n-1)q đơn vị thời gian.
Ví dụ: n = 10 tiến trình, q = 5 ms => 45ms trc nó là 9 tiến trình khác, ko có nào chờ quá 45ms.
- Nhận xét về giải thuật Round Robin:
+ Nếu q lớn: RR trở thành FCFS.
+ Nếu q nhỏ: phải tốn chi phí chuyển ngữ cảnh giữa các tiến trình -> q không nên quá nhỏ
+ Ưu tiên tiến trình hướng CPU.
+ RR sử dụng một giả thuyết ngầm là tất cả các tiến trình đều có tầm quan trọng ngang nhau.
+ Ưu điểm: Thời gian đáp ứng nhỏ
+ Hạn chế: Thời gian chờ đợi trung bình và thời gian hoàn thành trung bình của giải thuật RR thường khá lớn.
- Quantum time và hiệu suất hệ thống:
+ Khi thực hiện chuyển ngữ cảnh, kernel thread sẽ sử dụng CPU, không phải user thread.
+ Phí tổn hệ thống (OS Overhead): thời gian sử dụng CPU sẽ để thực hiện chuyển ngữ cảnh.
- Hiệu suất hệ thống: tùy thuộc vào kích thước quanntum time
+ Nếu quantum time ngắn: thời gian đáp ứng nhanh, nhưng phí tổn hệ thống lớn do số lần chuyển ngữ cảnh tăng.
+ Nếu quantum time dài: hiệu quả sử dụng CPU tốt hơn, nhưng thời gian đáp ứng cũng lớn.
+ Nếu quantum time quá lớn: RR trở thành FCFS.
--- QUIZ ---
Câu hỏi: Những nhận xét nào sau đây là SAI khi nói về giải thuật Round Robin?
A. Nếu Quantum quá lớn, giải thuật Round Robin sẽ trở thành giải thuật FCFS,
B. Quantum time phải luôn lớn hơn hoặc bằng thời gian chuyển ngữ cảnh
C. Nếu Quantum time quá nhỏ, phí tổn hệ thống sẽ lớn.
D. Khi tăng Quantum time, thời gian hoàn thành trung bình của các tiến trình sẽ được cải thiện.
Answer key: B, D.
6. Giải thuật Highest-Response-Ratio-Next:
- Chọn tiến trình kế tiếp có giá trị RR (Response ratio) lớn nhất:
RR = time spent waiting + expected service time / expected service time = waiting + burst + 1
- Các tiến trình ngắn được ưu tiên hơn vì có service time nhỏ.
--- QUIZ ---
Câu 1: Tại sao các tiến trình ngắn lại được ưu tiên trong giải thuật HRN:
A. Vì thời gian thực thi nhỏ làm tăng chỉ số "response ratio"
B. Vì thời gian chờ đợi lớn làm tăng chỉ số "response ratio"
C. Vì các tiến trình ngắn hoàn thành nhanh chóng hơn
Answer key: A. Vì thời gian thực thi nhỏ làm tăng chỉ số "response ratio"
Câu 2: Giải thuật HRRN và cơ chế "aging" có điểm gì giống nhau?
A. Cả 2 đều tập trung vào giảm thời gian chờ đợi của tiến trình dài
B. Cả 2 đều giảm độ ưu tiên của tiến trình theo thời gian
C. Cả 2 đều tăng độ ưu tiên của tiến trình theo thười gian để tránh tình trạng đói.
Answer key: C. Cả 2 đều tăng độ ưu tiên của tiến trình theo thười gian để tránh tình trạng đói.
Câu 3: Trong giải thuật HRRN, chỉ số "response ratio" (RR) được tính ntn?
A. Bằng tổng thời gian chờ đợi chia cho thời gian thực thi ước tính.
B. Bằng tổng thời gian chờ đợi cộng với thời gian thực thi ước tính, chia cho thời gian thực ước tính
C. Bằng thời gian thực thi ước tính chia cho thời gian chờ đợi.
Answer key: B. Bằng tổng thời gian chờ đợi cộng với thời gian thực thi ước tính, chia cho thời gian thực ước tính
7. Giải thuật Multilevel Queue:
- Ready queue được chia thành nhiều hàng đợi riêng biệt theo một số tiêu chuẩn sau:
+ Đặc điểm và yêu cầu định thời của tiến trình
+ Phân loại tiến trình: Foreground (interactive) và background,...
- Tiến trình được gán cố định vào một hàng đợi, mỗi hàng đợi sử dụng giải thuật định thời riêng.
- Việc định thời giữa các hàng đợi:
+ Hệ điều hành cần phải định thời cho các hàng đợi:
. Fixed priority scheduling: phục vụ từ hàng đợi có độ ưu tiên cao đến thấp -> có thể phát sinh vấn đề đói tài nguyên.
. Time slice: mỗi hàng đợi được nhận một khoảng thời gian chiếm CPU và phân phối cho các tiến trình trong hàng đợi khoảng thời gian đó.
Ví dụ: 80% cho hàng đợi foreground định thời bằng RR và 20% cho hàng đợi background định thời bằng giải thuật FCFS.
- Hạn chế của MUltilevel Queue:
- Tiến trình không thể chuyển từ hàng đợi này sang hàng đợi khác:
-> Có thể làm giảm hiệu suất hệ thống trong trường hợp một hàng đợi có nhiều tiến trình trong khi các hàng đợi khác lại trống.
-> Khắc phục bằng cơ chế feedback: cho phép tiến trình di chuyển một cách thích hợp giữa các hàng đợi khác nhau.
8. Giải thuật Multilevel Feedback Queue:
- Phân loại tiến trình dựa trên các đặc tính về CPU-burst.
- Sử dụng chế độ trưng dụng (preemptive).
- Sau một khoảng thời gian nào đó, các tiến trình hướng I/O và tiến trình interactive sẽ ở các hàng đợi có độ ưu tiên cao hơn còn các tiến trình hướng CPU sẽ ở các hàng đợi có độ ưu tiên thấp hơn.
- Một tiến trình đã chờ quá lâu ở một hàng đợi có độ ưu tiên thấp có thể được chuyển đến hàng đợi có độ ưu tiên cao hơn (cơ chế aging).
- Các vấn đề:
+ Số lượng hàng đợi bao nhiêu là thích hợp?
+ Dùng giải thuật định thời nào ở mỗi hàng đợi?
+ Làm sao để xác định thời điểm cần chuyển một tiến trình đến hàng đợi cao hơn hoặc thấp hơn?
+ Khi tiến trình yêu cầu được xử lý thì đưa vào hàng đợi nào là hợp lý nhất?
--- QUIZ ---
Câu 1: Trong giải thuật Multilevel Feedback Queue, điều gì xảy ra nếu một tiến trình chờ đợi quá lâu ở hàng đợi có độ ưu tiên thấp?
A. Tiến trình sẽ bị hủy bỏ.
B. Tiến trình sẽ được chuyển lên hàng đợi có độ ưu tiên cao hơn.
C. Tiến trình sẽ được giữ nguyên ở hàng đợi đó.
Answer key: B. Tiến trình sẽ được chuyển lên hàng đợi có độ ưu tiên cao hơn.
Câu 2: Trong giải thuật Multilevel Queue, các tiến trình được chia thành các hàng đợi khác nhau dựa trên tiêu chí nào?
A. Độ dài của tiến trình
B. Độ phức tạp của thuật toán
C. Đặc điểm và yêu cầu định thời của tiến trình.
Answer key: C. Đặc điểm và yêu cầu định thời của tiến trình.
Câu 3: Điều gì xảy ra nếu hàng đợi có độ ưu tiên thấp hơn không được cấp phát đủ thời gian CPU trong giải thuật Multilevel Queue?
A. Tiến trình sẽ bị dừng lại
B. Các tiến trình trong hàng đợi đó có thể gặp vấn đề starvations (đói tài nguyên)
C. Hệ thống sẽ tự động tăng độ ưu tiên cho hàng đợi đó.
Answer key: B. Các tiến trình trong hàng đợi đó có thể gặp vấn đề starvations (đói tài nguyên)
Câu 4: Giải thuật Multilevel Feedback Queue khác gì so với Multilevel Queue?
A. Multilevel Feedback Queue sử dụng duy nhất một loại giải thuật định thời.
B. Multilevel Feedback Queue không có sự khác biệt so với Multilevel Queue.
C. Multilevel Feedback Queue cho phép tiến trình chuyển giữa các hàng đợi khác nhau.
Answer key: C. Multilevel Feedback Queue cho phép tiến trình chuyển giữa các hàng đợi khác nhau.
Câu 5: Thách thức chính khi triển khai giải thuật Multilevel Feedback Queue là gì?
A. Xác định số lượng hàng đợi và giải thuật định thời cho mỗi hàng đợi. (*)
B. Đảm bảo tất cả các tiến trình đều sử dụng cùng một hàng đợi.
C. Tránh sử dụng giải thuật định thời khác nhau cho các hàng đợi.
Answer key: A. Xác định số lượng hàng đợi và giải thuật định thời cho mỗi hàng đợi. (*)
Câu 6: Hạn chế lớn nhất của giải thuật Multilevel Queue là gì?
A. Các tiến trình không thể chia sẻ tài nguyên
B. Các tiến trình không thể tương tác với nhau
C. Các tiến trình không thể chuyể từ hàng đợi này sang hàng đợi khác.
Answer key: C. Các tiến trình không thể chuyể từ hàng đợi này sang hàng đợi khác.
9. So sánh các giải thuật:
- Các yếu tố quyết định giải thuật nào tốt nhất:
+ Tần suất tải việc (System workload).
+ Sự hỗ trợ của phần cứng đối với dispatcher.
+ Sự tương quan về trọng số của các tiêu chuẩn định thời như response time, hiệu suất CPU, throughput,...
+ Phương pháp định lượng so sánh.
