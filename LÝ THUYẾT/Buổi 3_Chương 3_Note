CHƯƠNG 3: QUẢN LÝ TIẾN TRÌNH
I. Khái niệm cơ bản:
- Một hệ điều hành thực thi chương trình như là một tiến trình.
- Tiến trình là một chương tình đang thực thi.
- Chương trình là thực thể bị động lưu trển đĩa, tiến trình là thực thể chủ động.
- Thực thể bị động: không gây ra thay đổi, tác động nào lên máy tính của chúng ta.
- Thực thể chủ động: khi gọi tiến trình, tiến trình sử dụng tài nguyên trong máy tính của chúng ta.
- Chương trình sẽ trở thành tiến trình khi một tập tin thực thi được nạp vào bộ nhớ chính (RAM).
- Một tiến trình bao gồm:
+ Text section (program code) (chứa source code).
+ Data section (chứa global variable) (biến toàn cục).
+ Program counter (con trỏ PC trỏ tới câu lệnh chạy tiếp theo), program registers (giúp thao tác Xử lý các phép toán số học, logic)
+ Heap section (chứa bộ nhớ cấp phát động - dựa trên nhu cầu thực tế để cấp phát bộ nhớ).
+ Stack section (chứa dữ liệu tạm thời): function parameters, return address và local variable.
- Stack và heap section có thể co giãn, heap có thể điều chỉnh theo nhu cầu, có thể dùng lệnh delete sau cấp phát động xong, hàm stack cũng tương tự.
--- QUIZ ---
Câu 1: 
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{
    if (argc > 2)
        printf("Hello, %s\n", argv[1]);
}
Biết đoạn chương trình trên là source code của chương trình tên là test. Nếu thực thi lệnh ./test He Dieu Hanh thì chương trình sẽ ra gì?
Answer key: Hello, He.
Câu 2: Những phát biểu nào sau đây là đúng khi nói về tiến trình?
A. Tiến trình không gây ra thay đổi gì trên hệ thống máy tính.
B. Sau khi cài đặt xong, chương trình sẽ trở thành tiến trình.
C. Tiến trình được lưu trên bộ nhớ chính.
D. Tiến trình là thực thể chủ động.
Answer key: C, D.
Câu 3: Tiến trình KHÔNG bao gồm thành phần nào sau đây?
A. Địa chỉ trả về sau hoàn tất hàm.
B. Đoạn mã khởi động máy tính
C. Con trỏ chỉ câu lệnh thực thi tiếp theo
D. Các thanh ghi.
Answer key: B.
Câu 4: Trong các vùng nhớ sau, vùng nhớ nào có khả năng thay đổi kích thước khi tiến trình thực thi?
A. Text section
B. Data section
C. Heap section
D. Stack section.
Answer key: C, D.
- Các bước nạp chương trình vào bộ nhớ:
Chương trình được viết bằng ngôn ngữ C sau đó được biên dịch qua sự hỗ trợ của Assembler hoặc Compiler thành Object modules rồi sử dụng Linker để gộp rồi tạo thành executable binary file (fie khả thực thi) đang lưu trong ổ cứng, thì dùng Loader nạp chương trình nạp lên bộ nhớ chính thì chúng ta sẽ có process image in memory.
- Các bước khởi tạo tiến trình:
+ Cấp phát một định danh duy nhất cho tiến trình. (PID).
+ Cấp phát không gian nhớ để nạp tiến trình.
+ Khởi tạo khối dữ liệu Process Control Block (PCB) cho tiến trình.
+ Thiết lập các mối liên hệ cần thiết (ví dụ: sắp PCB vào hàng đợi định thời...)
--- QUIZ ---
Câu 1: Phát biểu sau Đúng (True) hay Sai (False): Một chương trình chỉ có thể tạo ra một tiến trình.
Answer key: False.
Câu 2: Để tạo một tiến trình, KHÔNG cần phải trải qua câc bước nào sau đây?
A. Cấp phát không gian nhớ để nạp tiến trình
B. Cấp phát một định danh duy nhất cho tiến trình
C. Khởi tạo khối thanh ghi cho tiến trình
D. Khởi tạo khối dữ liệu Process Control Block (PCB).
Answer key: C. Khởi tạo khối thanh ghi cho tiến trình
II. Trạng thái của tiến trình:
- new: tiến trình vừa được tạo
- ready: tiến trình đã có đủ tài nguyên, chỉ còn cần CPU.
- running: các lệnh của tiến trình đang được thực thi.
- waiting (hay blocked): tiến trình đợi I/O hoàn tất, hoặc đợi tín hiệu.
- terminated: tiến trình đã kết thúc.
- Chuyển dổi giữa các tiến trình: new qua admit -> ready qua dispatch -> running có thể quay lại ready nếu là interrupt hoặc I/O or event wait thành -> waiting -? ready. Nếu xong rồi thì thành exit.
---QUIZ---
Câu 1: Hoàn thành chuỗi chuyển trạng thái sau của một tiến trình:
...--> Ready --> Running --> Waiting --> ... --> .... --> Terminated.
Answer key: New --> Ready --> Running --> Waiting --> Ready --> Running --> Terminated.
Câu 2: Tìm phát biểu SAI trong các phát biểu sau: 
A. Có thể có nhiều process ở trạng thái READY tại một thời điểm.
B. Có thể có nhiều process ở trạng thái RUNNING trên mỗi nhân xử lý tại một thời điểm.
C. Khi tiến trình được cấp đủ tài nguyên và chỉ còn chờ CPU, tiến trình đó sẽ ở trạng thái READY.
D. Tên của các trạng thái có thể khác nhau trên các hệ điều hành khác nhau nhưng bản chất trạng thái mà chúng mô tả là như nhau.
Answer key: B. Chính xác: Tại một thời điểm, chỉ có DUY NHẤT MỘT TIẾN TRÌNH ở trạng thái RUNNING trên mỗi nhân xử lý.
Câu 3: 
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{
    int a, b = 0, i;
    for (i = 10; i >= 6; i--)
    {
        if (i % 3 == 0)
            printf("So %d chia het cho 3\n", i);
        else
            a = b + i;
    }
    exit(0);
}
Cho đoạn chương trình như trong hình, hỏi sau khi kết thúc xong thì tiến trình tạo ra từ chương trình trên đã ở trạng thái bao nhiêu lần?
Answer key: 
Trạng thái READY: 5 lần
Trạng thái RUNNING: 5 lần
Trạng thái WAITING: 4 lần
III. Process Control Block:
- Mỗi tiến trình trong hệ thống đều được cấp phát một Process Control Block (PCB).
+ PCB là môt trong các cấu trúc dữ liệu quan trọng nhất của hệ điều hành.
- PCB gồm:
+ Trạng thái tiến trình: new, ready, running,...
+ Bộ đếm chương trình
+ Các thanh ghi
+ Thông tin lập thời biểu CPU: độ ưu tiên,...
+ Thông tin quản lý bộ nhớ
+ Thông tin: lượng CPU, thời gian sử dụng
+ Thông tin trạng thái I/O.
IV. Định thời tiến trình:
- Yêu cầu đối với hệ điều hành và quản lý tiến trình:
+ Hỗ trợ sự thực thi luân phiên giữa nhiều tiến trình:
. Hiệu suất sử dụng CPU.
. Thời gian đáp ứng.
+ Phân phối tài nguyên hệ thống hợp lý.
+ Tránh deadlock, trì hoãn vô hạn định.
+ Cung cấp cơ chế giao tiếp và đồng bộ hoạt động các tiến trình.
+ Cung cấp cơ chế hỗ trợ user tạo/kết thúc tiến trình.
- Tại sao phải định thời?
+ Đa chương:
. Có vài tiến trình chạy tại các thời điểm.
. Mục tiêu: tận dụng tối đa CPU.
+ Chia thời:
. User tương tác với mỗi chương trình đang thực thi.
. Mục tiêu: tối thiểu thời gian đáp ứng.
--- QUIZ --- 
Câu 1: Ý nào sau đây KHÔNG phải là yêu cầu của hệ điều hành về quản lý tiến trình?
A. Phân phối tài nguyên hệ thống hợp lý.
B. Hô trợ sự thực thi luân phiên giữa nhiều tiến trình
C. Cung cấp cơ chế giao tiếp và đồng bộ hoạt động các tiến trình
D. Hỗ trợ tiến trình sử dụng CPU lâu nhất có thể.
Answer key: D. Hỗ trợ tiến trình sử dụng CPU lâu nhất có thể.
Câu 2: Điền vào chỗ trống:
Hệ điều hành tổ chức các hàng đợi định thời để sắp xếp thứ tự cho các tiến trình, phần tử trong các hàng đợi định thời này chính là các ... của các tiến trình.
Answer key: PCB.
1. Các hàng đợi định thời:
- Hàng đợi công việc: Job queue: chứa danh sách những tiến trình đang chờ đợi nạp vào bộ nhớ chính và thực thi công việc của mình.
- Hàng đợi sẵn sàng: Ready queue: chứa danh sách những tiến trình đã có đầy đủ tài nguyên chỉ thiếu CPU thì bắt đầu được quá trình thực thi.
- Hàng đợi thiết bị - Device queues.
--- QUIZ ---
Câu 1: Chọn phát biểu đúng khi nói về các hàng đợi định thời trong hệ điều hành?
A. Hệ điều hành sử dụng hàng đợi định thời để sắp xếp thứ tự thực thi của các tiến trình.
B. Khi tiến trình muốn in một dòng dữ liệu ra màn hình, nó phải chờ trong hàng đợi công việc.
C. Hệ điều hành chỉ có 2 loại hàng đợi định thời là hàng đợi công việc và hàng đợi sẵn sàng.
D. Hàng đợi thiết bị dùng để sắp xếp thứ tự các thiết bị sử dụng khi tiến trình thực thi.
Answer key: A. Hệ điều hành sử dụng hàng đợi định thời để sắp xếp thứ tự thực thi của các tiến trình.
Câu 2: Tiến trình sẽ vào trạng thái WAITING khi thực hiện NHỮNG việc nào sau đây?
A. Tiến trình in dữ liệu ra màn hình
B. Tiến trình thực thi sau khi tiến trình con thực thi
C. Một ngắt xuất hiện khi tiến trình thực thi
D. Tiến trình hết thời gian time slice.
Answer key: A, B, C.
2. Bộ định thời:
- Phân loại tiến trình:
+ Các tiến trình có thể mô tả như: tiến trình I/O (tương tác với người dùng), tiến trình hướng CPU (xu hướng tương tác với CPU, đảm bảo hiệu suất).
+ Thời gian thực hiện khác nhau -> kết hợp hài hòa giữa chúng.
- Phân loại bộ định thời:
+ Bộ định thời công việc (Job scheduler) hay bộ định thời dài (long-term scheduler).
+ Bộ định thời CPU (CPU scheduler) hay bộ định thời ngắn (short-term scheduler).
- Bộ định thời trung gian/vừa:
+ Degree of multiprogramming: Mức độ đa chương của hệ thống dùng để chỉ số lượng tiến trình tối đa mà hệ thống có thể xử lý hiệu quả.
+ Chuyển tiến trình từ bộ nhớ sang đĩa (swap out), chuyển tiến trình từ đĩa vào bộ nhớ (swap in).
Ban đầu có các tiến trình trong ready queue, ng dùng mún mở thêm tiến trình Pn, thì nạp vào bộ nhớ chính, nếu bộ nhớ chính đã đầy thì swap out, chuyển bớt tiến trình trong ready, nạp tiến trình mới
-> gia tăng mức độ đa chương
- Chuyển ngữ cảnh: Qúa trình CPU chuyển từ tiến trình này đến tiến trình khác.
--- QUIZ ---
Câu 1: Các bộ định thời nào sau đây có ảnh hưởng đến mức độ đa chương của hệ thống?
A. Bộ định thời dài.
B. Bộ định thời trung gian/vừa
C. Bộ định thời ngắn
Answer key: A, B.
Câu 2: Tiến trình hướng I/O KHÔNG có đặc điểm nào sau đây?
A. Là các tiến trình mang tính tương tác cao
B. Yêu cầu thực thi CPU trong thời gian dài
C. Ít tốn thời gian cho việc chuyển ngữ cảnh
D. Dành nhiều thời gian xử lý I/O.
Answer key: B. Yêu cầu thực thi CPU trong thời gian dài
