CHƯƠNG 3: QUẢN LÝ TIẾN TRÌNH
I. Khái niệm cơ bản:
- Một hệ điều hành thực thi chương trình như là một tiến trình.
- Tiến trình là một chương tình đang thực thi.
- Chương trình là thực thể bị động lưu trển đĩa, tiến trình là thực thể chủ động.
- Thực thể bị động: không gây ra thay đổi, tác động nào lên máy tính của chúng ta.
- Thực thể chủ động: khi gọi tiến trình, tiến trình sử dụng tài nguyên trong máy tính của chúng ta.
- Chương trình sẽ trở thành tiến trình khi một tập tin thực thi được nạp vào bộ nhớ chính (RAM).
- Một tiến trình bao gồm:
+ Text section (program code) (chứa source code).
+ Data section (chứa global variable) (biến toàn cục).
+ Program counter (con trỏ PC trỏ tới câu lệnh chạy tiếp theo), program registers (giúp thao tác Xử lý các phép toán số học, logic)
+ Heap section (chứa bộ nhớ cấp phát động - dựa trên nhu cầu thực tế để cấp phát bộ nhớ).
+ Stack section (chứa dữ liệu tạm thời): function parameters, return address và local variable.
- Stack và heap section có thể co giãn, heap có thể điều chỉnh theo nhu cầu, có thể dùng lệnh delete sau cấp phát động xong, hàm stack cũng tương tự.
--- QUIZ ---
Câu 1: 
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{
    if (argc > 2)
        printf("Hello, %s\n", argv[1]);
}
Biết đoạn chương trình trên là source code của chương trình tên là test. Nếu thực thi lệnh ./test He Dieu Hanh thì chương trình sẽ ra gì?
Answer key: Hello, He.
Câu 2: Những phát biểu nào sau đây là đúng khi nói về tiến trình?
A. Tiến trình không gây ra thay đổi gì trên hệ thống máy tính.
B. Sau khi cài đặt xong, chương trình sẽ trở thành tiến trình.
C. Tiến trình được lưu trên bộ nhớ chính.
D. Tiến trình là thực thể chủ động.
Answer key: C, D.
Câu 3: Tiến trình KHÔNG bao gồm thành phần nào sau đây?
A. Địa chỉ trả về sau hoàn tất hàm.
B. Đoạn mã khởi động máy tính
C. Con trỏ chỉ câu lệnh thực thi tiếp theo
D. Các thanh ghi.
Answer key: B.
Câu 4: Trong các vùng nhớ sau, vùng nhớ nào có khả năng thay đổi kích thước khi tiến trình thực thi?
A. Text section
B. Data section
C. Heap section
D. Stack section.
Answer key: C, D.
- Các bước nạp chương trình vào bộ nhớ:
Chương trình được viết bằng ngôn ngữ C sau đó được biên dịch qua sự hỗ trợ của Assembler hoặc Compiler thành Object modules rồi sử dụng Linker để gộp rồi tạo thành executable binary file (fie khả thực thi) đang lưu trong ổ cứng, thì dùng Loader nạp chương trình nạp lên bộ nhớ chính thì chúng ta sẽ có process image in memory.
- Các bước khởi tạo tiến trình:
+ Cấp phát một định danh duy nhất cho tiến trình. (PID).
+ Cấp phát không gian nhớ để nạp tiến trình.
+ Khởi tạo khối dữ liệu Process Control Block (PCB) cho tiến trình.
+ Thiết lập các mối liên hệ cần thiết (ví dụ: sắp PCB vào hàng đợi định thời...)
--- QUIZ ---
Câu 1: Phát biểu sau Đúng (True) hay Sai (False): Một chương trình chỉ có thể tạo ra một tiến trình.
Answer key: False.
Câu 2: Để tạo một tiến trình, KHÔNG cần phải trải qua câc bước nào sau đây?
A. Cấp phát không gian nhớ để nạp tiến trình
B. Cấp phát một định danh duy nhất cho tiến trình
C. Khởi tạo khối thanh ghi cho tiến trình
D. Khởi tạo khối dữ liệu Process Control Block (PCB).
Answer key: C. Khởi tạo khối thanh ghi cho tiến trình
II. Trạng thái của tiến trình:
- new: tiến trình vừa được tạo
- ready: tiến trình đã có đủ tài nguyên, chỉ còn cần CPU.
- running: các lệnh của tiến trình đang được thực thi.
- waiting (hay blocked): tiến trình đợi I/O hoàn tất, hoặc đợi tín hiệu.
- terminated: tiến trình đã kết thúc.
- Chuyển dổi giữa các tiến trình: new qua admit -> ready qua dispatch -> running có thể quay lại ready nếu là interrupt hoặc I/O or event wait thành -> waiting -? ready. Nếu xong rồi thì thành exit.
---QUIZ---
Câu 1: Hoàn thành chuỗi chuyển trạng thái sau của một tiến trình:
...--> Ready --> Running --> Waiting --> ... --> .... --> Terminated.
Answer key: New --> Ready --> Running --> Waiting --> Ready --> Running --> Terminated.
Câu 2: Tìm phát biểu SAI trong các phát biểu sau: 
A. Có thể có nhiều process ở trạng thái READY tại một thời điểm.
B. Có thể có nhiều process ở trạng thái RUNNING trên mỗi nhân xử lý tại một thời điểm.
C. Khi tiến trình được cấp đủ tài nguyên và chỉ còn chờ CPU, tiến trình đó sẽ ở trạng thái READY.
D. Tên của các trạng thái có thể khác nhau trên các hệ điều hành khác nhau nhưng bản chất trạng thái mà chúng mô tả là như nhau.
Answer key: B. Chính xác: Tại một thời điểm, chỉ có DUY NHẤT MỘT TIẾN TRÌNH ở trạng thái RUNNING trên mỗi nhân xử lý.
Câu 3: 
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{
    int a, b = 0, i;
    for (i = 10; i >= 6; i--)
    {
        if (i % 3 == 0)
            printf("So %d chia het cho 3\n", i);
        else
            a = b + i;
    }
    exit(0);
}
Cho đoạn chương trình như trong hình, hỏi sau khi kết thúc xong thì tiến trình tạo ra từ chương trình trên đã ở trạng thái bao nhiêu lần?
Answer key: 
Trạng thái READY: 5 lần
Trạng thái RUNNING: 5 lần
Trạng thái WAITING: 4 lần
III. Process Control Block:
- Mỗi tiến trình trong hệ thống đều được cấp phát một Process Control Block (PCB).
+ PCB là môt trong các cấu trúc dữ liệu quan trọng nhất của hệ điều hành.
- PCB gồm:
+ Trạng thái tiến trình: new, ready, running,...
+ Bộ đếm chương trình
+ Các thanh ghi
+ Thông tin lập thời biểu CPU: độ ưu tiên,...
+ Thông tin quản lý bộ nhớ
+ Thông tin: lượng CPU, thời gian sử dụng
+ Thông tin trạng thái I/O.
IV. Định thời tiến trình:
- Yêu cầu đối với hệ điều hành và quản lý tiến trình:
+ Hỗ trợ sự thực thi luân phiên giữa nhiều tiến trình:
. Hiệu suất sử dụng CPU.
. Thời gian đáp ứng.
+ Phân phối tài nguyên hệ thống hợp lý.
+ Tránh deadlock, trì hoãn vô hạn định.
+ Cung cấp cơ chế giao tiếp và đồng bộ hoạt động các tiến trình.
+ Cung cấp cơ chế hỗ trợ user tạo/kết thúc tiến trình.
- Tại sao phải định thời?
+ Đa chương:
. Có vài tiến trình chạy tại các thời điểm.
. Mục tiêu: tận dụng tối đa CPU.
+ Chia thời:
. User tương tác với mỗi chương trình đang thực thi.
. Mục tiêu: tối thiểu thời gian đáp ứng.
--- QUIZ --- 
Câu 1: Ý nào sau đây KHÔNG phải là yêu cầu của hệ điều hành về quản lý tiến trình?
A. Phân phối tài nguyên hệ thống hợp lý.
B. Hô trợ sự thực thi luân phiên giữa nhiều tiến trình
C. Cung cấp cơ chế giao tiếp và đồng bộ hoạt động các tiến trình
D. Hỗ trợ tiến trình sử dụng CPU lâu nhất có thể.
Answer key: D. Hỗ trợ tiến trình sử dụng CPU lâu nhất có thể.
Câu 2: Điền vào chỗ trống:
Hệ điều hành tổ chức các hàng đợi định thời để sắp xếp thứ tự cho các tiến trình, phần tử trong các hàng đợi định thời này chính là các ... của các tiến trình.
Answer key: PCB.
1. Các hàng đợi định thời:
- Hàng đợi công việc: Job queue: chứa danh sách những tiến trình đang chờ đợi nạp vào bộ nhớ chính và thực thi công việc của mình.
- Hàng đợi sẵn sàng: Ready queue: chứa danh sách những tiến trình đã có đầy đủ tài nguyên chỉ thiếu CPU thì bắt đầu được quá trình thực thi.
- Hàng đợi thiết bị - Device queues.
--- QUIZ ---
Câu 1: Chọn phát biểu đúng khi nói về các hàng đợi định thời trong hệ điều hành?
A. Hệ điều hành sử dụng hàng đợi định thời để sắp xếp thứ tự thực thi của các tiến trình.
B. Khi tiến trình muốn in một dòng dữ liệu ra màn hình, nó phải chờ trong hàng đợi công việc.
C. Hệ điều hành chỉ có 2 loại hàng đợi định thời là hàng đợi công việc và hàng đợi sẵn sàng.
D. Hàng đợi thiết bị dùng để sắp xếp thứ tự các thiết bị sử dụng khi tiến trình thực thi.
Answer key: A. Hệ điều hành sử dụng hàng đợi định thời để sắp xếp thứ tự thực thi của các tiến trình.
Câu 2: Tiến trình sẽ vào trạng thái WAITING khi thực hiện NHỮNG việc nào sau đây?
A. Tiến trình in dữ liệu ra màn hình
B. Tiến trình thực thi sau khi tiến trình con thực thi
C. Một ngắt xuất hiện khi tiến trình thực thi
D. Tiến trình hết thời gian time slice.
Answer key: A, B, C.
2. Bộ định thời:
- Phân loại tiến trình:
+ Các tiến trình có thể mô tả như: tiến trình I/O (tương tác với người dùng), tiến trình hướng CPU (xu hướng tương tác với CPU, đảm bảo hiệu suất).
+ Thời gian thực hiện khác nhau -> kết hợp hài hòa giữa chúng.
- Phân loại bộ định thời:
+ Bộ định thời công việc (Job scheduler) hay bộ định thời dài (long-term scheduler).
+ Bộ định thời CPU (CPU scheduler) hay bộ định thời ngắn (short-term scheduler).
- Bộ định thời trung gian/vừa:
+ Degree of multiprogramming: Mức độ đa chương của hệ thống dùng để chỉ số lượng tiến trình tối đa mà hệ thống có thể xử lý hiệu quả.
+ Chuyển tiến trình từ bộ nhớ sang đĩa (swap out), chuyển tiến trình từ đĩa vào bộ nhớ (swap in).
Ban đầu có các tiến trình trong ready queue, ng dùng mún mở thêm tiến trình Pn, thì nạp vào bộ nhớ chính, nếu bộ nhớ chính đã đầy thì swap out, chuyển bớt tiến trình trong ready, nạp tiến trình mới
-> gia tăng mức độ đa chương
- Chuyển ngữ cảnh: Qúa trình CPU chuyển từ tiến trình này đến tiến trình khác.
--- QUIZ ---
Câu 1: Các bộ định thời nào sau đây có ảnh hưởng đến mức độ đa chương của hệ thống?
A. Bộ định thời dài.
B. Bộ định thời trung gian/vừa
C. Bộ định thời ngắn
Answer key: A, B.
Câu 2: Tiến trình hướng I/O KHÔNG có đặc điểm nào sau đây?
A. Là các tiến trình mang tính tương tác cao
B. Yêu cầu thực thi CPU trong thời gian dài
C. Ít tốn thời gian cho việc chuyển ngữ cảnh
D. Dành nhiều thời gian xử lý I/O.
Answer key: B. Yêu cầu thực thi CPU trong thời gian dài
V. Các tác vụ đối với tiến trình:
- Tạo tiến trình mới:
+ Một tiến trình có thể tạo nhiều tiến trình mới thông qua một lời gọi hệ thống create-process (vd: hàm fork trong Unix).
. Ví dụ: Khi user đăng nhập hệ thống, một command interpreter (shell) sẽ được tạo ra cho user.
+ Tiến trình được tạo là tiến trình con của tiến trình tạo (tiến trình cha).
. Quan hệ cha-con định nghĩa một cây tiến trình.
1. Tạo tiến trình:
- Tiến trình con nhận tài nguyên: từ OS hoặc từ tiến trình cha.
- Chia sẻ tài nguyên của tiến trình cha:
+ Tiến trình cha và con chia sẻ mọi tài nguyên.
+ Tiến trình con chia sẻ một phần tài nguyên của cha (tài nguyên có thể là vùng nhớ, source code,...)
- Trình tự thực thi:
+ Tiến trình cha và con thực thi đồng thời (concurrently).
+ Tiến trình cha đợi đến khi các tiến trình con kết thúc.
- Hàm fork: Hàm tạo ra tiến trình mới:
+ Tiến trình con sao chép không gian địa chỉ của tiến trình cha -> Tiến trình con:
. Sao chép toàn bộ source code của tiến trình cha.
. Sao chép giá trị của các biến được tạo.
. Bắt đầu thực thi từ vị trí mà tiến trình được tạo.
+ Giá trị trả về của hàm fork sẽ thuộc 1 trong 3 trường hợp:
. Lớn hơn 0: cho biết đây là tiến trình cha.
. Bằng 0: cho biết đây là tiến trình con.
. Nhỏ hơn 0: hàm fork() thất bại.
--- QUIZ ---
Câu 1: Khi tiến trình thực thi hàm fork(), một tiến trình con sẽ được tạo ra giống hệt và chạy đồng thời cùng với tiến trình cha, như vậy làm thế nào có thể phân biệt đâu là tiến trình cha, đâu là tiến trình con trong source code?
A. Sau khi tạo ra tiến trình con, tiến trình cha chờ tiến trình con kết thúc rồi mới thực thi tiếp.
B. Sau khi được tạo ra, tiến trình con chờ tiến trình cha kết thúc kết thúc rồi mới thực thi tiếp.
C. Dựa vào giá trị trả về của hàm fork.
Answer key: C. Dựa vào giá trị trả về của hàm fork.
Câu 2: Tìm nhận xét SAI trong các nhận xét sau khi nói về thao tác tạo tiến trình:
A. Tiến trình con có thể được thực thi đồng thời cùng với tiến trình cha
B. Tiến trình cha có thể đợi cho đến khi tiến trình con kết thúc rồi mới thực thi tiếp
C. Tiến trình con luôn nhận tài nguyên từ hệ điều hành
D. Tiến trình con có thể chia sẻ tài nguyên với tài nguyên
Answer key: C. Tiến trình con luôn nhận tài nguyên từ hệ điều hành
Câu 3: Khi sử dụng hàm fork() để tạo tiến trình con, nhận định nào sau đây là đúng?
A. Hàm fork() luôn thực hiện thành công và trả về 2 giá trị hoặc là lớn hơn 0 hoặc là bằng 0.
B. Source code của tiến trình cha có thể khác so với source code của tiến trình cha
C. Tiến trình con copy toàn bộ các biến và giá trị của biến từ tiến trình cha.
D. Tiến trình con sau khi được tạo ra sẽ bắt dầu thực thi từ đầu chương trình.
Answer key: C. Tiến trình con copy toàn bộ các biến và giá trị của biến từ tiến trình cha.
- Họ hàm exec() : tạo tiến trình:
+ Nạp một tác vụ mới vào không gian địa chỉ của tiến trình gọi hàm:
. Tác vụ mới sẽ được ghi đè vào không gian địa chỉ của tiến trình.
. Tiến trình thực thi tác vụ mới thay vì source code ban đầu.
- Công thức:
execl ("/bin/ls", "ls", NULL) trong đó:
"/bin/ls": đường dẫn đến file muốn thực thi
"ls": tham số 0 (tên tiến trình, thường trùng với tên file thực thi)
NULL: tham số 1 (nếu không có thì là NULL), là tham số cuối cùng không có gì để liệt kê nữa.
- Công việc của tiến trình gọi họ hàm exec() sẽ bị thay thế bởi công việc khác được chỉ định trong tham số của hàm này.
- Về quan hệ cha con:
+ Không gian địa chỉ:
. Không gian địa chỉ của tiến trình con được nhân bản từ cha.
. Không gian địa chỉ của tiến trình con được khởi tạo từ template.
- Cách tạo tiến trình fork() sẽ giúp tiến trình con nhân bản không gian địa chỉ của tiến trình cha.
- Ví dụ trong Unix/Linux:
+ System call fork() tạo một tiến trình mới.
+ System call exec() dùng sau fork() để nạp một chương trình mới vào không gian nhớ của tiến trình mới.
--- QUIZ ---
Câu 1: 
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
    fork();
    fork();
    fork();
    fork();
    return 0;
}
Cho đoạn code như trong hình, hỏi sau khi chạy xong, có tổng cộng bao nhiêu process (Kể cả process cha) được sinh ra?
A. 8
B. 32
C. 4
D. 16
Answer key: D. 16.
Câu 2:
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main ()
{
    int pid;
    pid = fork();
    return 0;
}
NHỮNG phát biểu nào sau đây là đúng khi thực thi tiến trình được tạo ra từ chương trình trên:
A. Nếu giá trị của biến pid lớn hơn 0, đó chính là định danh của tiến trình con.
B. Nếu giá trị của biến pid lớn hơn 0, đó chính lf giá trị được trả về cho tiến trình con.
C. Biến pid đại diện cho định danh của tiến trình
D. Tiến trình con sẽ kết thúc ngay khi vừa được tạo ra.
Answer key: A. Nếu giá trị của biến pid lớn hơn 0, đó chính là định danh của tiến trình con.
Chính xác: biến pid mang giá trị trả về từ hàm fork(), nếu giá trị này lớn hơn 0 thì sẽ được trả về cho tiến trình cha, mang ý nghĩa đây là định danh của tiến trình con.
D. Tiến trình con sẽ kết thúc ngay khi vừa được tạo ra.
Chính xác: Điều này do tiến trình con sẽ bắt đầu thực thi từ vị trí rời khỏi hàm fork(), chính là lệnh return 0 (kết thúc chương trình)
Câu 3: Trong hệ điều hành Linux, họ hàm exec() được sử dụng để:
A. Tạo ra một luồng mới trong tiến trình hiện tại
B. Gửi tín hiệu dừng tới một tiến trình khác.
C. Thay thế không gian địa chỉ của tiến trình hiện tại bằng một chương trình mới.
D. Tạo một tiến trình mới bằng cách sao chép tiến trình cha
Answer key: C. Thay thế không gian địa chỉ của tiến trình hiện tại bằng một chương trình mới.
2. Kết thúc tiến trình:
- Tiến trình tự kết thúc:
+ Tiến trình kết thúc khi thực thi lệnh cuối và gọi system routine exit.
- Tiến trình kết thúc do tiến trình khác (có đủ quyền, vd: tiến trình cha của nó)
+ Gọi system routine abort với tham số là pid (process identifier) của tiến trình cần được kết thúc.
- Hệ điều hành thu hồi tất cả các tài nguyên của tiến trình kết thúc (vùng nhớ, I/O buffer,...)
--- QUIZ ---
Câu 1: Điền vào chỗ trống:
Khi tiến trình bị kết thúc, hệ điều hành sẽ ... tất cả các tài nguyên của tiến trình (như vùng nhớ, I/O,...)
Answer key: thu hồi.
Câu 2: Tiến trình có thể kết thúc do NHỮNG trường hợp nào sau đây?
A. Người dùng bấm tổ hợp phím Ctrl+C khi chương trình đang thực thi
B. Tiến trình gặp hàm exit()
C. Tiến trình bị tiến trình con thực hiện thao tác kill
D. Tiến trình bị tiến trình cha thực hiện thao tác abort(). 
Answer key: A, B, D.
VI. Cộng tác giữa các tiến trình:
- Trong tiến trình thực thi, các tiến trình có thể cộng tác (cooperate) để hoàn thành công việc.
- Sự cộng tác giữa các tiến trình yêu cầu hệ điều hành hỗ trợ cơ chế giao tiếp và cơ chế đồng bộ hoạt động của các tiến trình.
- Các tiến trình cộng tác để:
+ Chia sẻ dữ liệu (information sharing).
+ Tăng tốc tính toán (computational speedup)
. Nếu hệ thống có nhiều CPU, chia công việc tính toán thành nhiều công việc tính toán nhỏ chạy song song.
+ Thực hiện một công việc chung:
. Xây dựng một phần mềm phức tạp bằng cách chia thành các module/process hợp tác nhau.
1. Giao tiếp liên tiếp trình (IPC):
- IPC (Inter Process Communication) là cơ chế cung cấp bởi hệ điều hành nhằm giúp các tiến trình:
+ Giao tiếp với nhau
+ Đồng bộ hoạt động.
- Hai mô hình IPC: Shared memory và Message passing.
- Shared memory: Tiến trình A có thể truy cập vào bộ nhớ chia sẻ và cả tiến trình B cũng có thể truy cập vào bộ nhớ chia sẻ.
- Message passing: Tiến trình A và B có thể có chung message queue để chúng ta có thể truyền bit qua này.
2. Bộ nhớ được chia sẻ - Shared memory:
- Một vùng nhớ dùng chung (được chia sẻ chung) giữa các tiến tình cần giao tiếp với nhau.
- Qúa trình giao tiếp được thực hiện dưới sự điều khiển của các tiến trình, không phải của hệ điều hành.
- Cần có cơ chế đồng bộ hoạt động của các tiến trình khi chúng cùng truy cập bộ nhớ dùng chung.
3. Hệ thống truyền thông điệp - Message passing:
- Đặt tên (Naming):
+ Giao tiếp trực tiếp:
. send(P, msg): gửi thông điệp đến tiến trình P.
. receive(Q, msg): nhận thông điệp đến từ tiến trình Q.
+ Giao tiếp gián tiếp: thông qua mailbox hay port
. send(A, msg): gửi thông điệp đến mailbox A.
. receive(Q, msg): nhận thông điệp từ mailbox B.
- Đồng bộ hóa (Synchronization): blocking send, nonblocking send, blocking receive, nonblocking receive.
- Các tiến trình giao tiếp nhau thông qua vùng đệm (Buffering): dùng queue để tạm chứa các message.
+ Khả năng chứa là O (Zero capacity hay no buffering).
+ Bounded capacity: độ dài của queue là giới hạn.
+ Unbounded capacity: độ dài của queue là không giới hạn.
--- QUIZ ---
Câu 1: Phát biểu nào sau đây là SAI khi nói về sự cộng tác giữa các tiến trình?
A. Các tiến trình có thể hoàn toàn làm chủ trong việc cộng tác và giao tiếp với nhau.
B. Tiến trình cộng tác để chia sẻ dữ liệu với nhau.
C. Việc công tác giữa các tiến trình có thể làm tăng tốc độ tính toán
D. Tiến trình có thể thực hiện các công việc chung thông qua việc cộng tác với nhau.
Answer key: A. Các tiến trình có thể hoàn toàn làm chủ trong việc cộng tác và giao tiếp với nhau.
Câu 2: Đây là ưu thế của cơ chế giao tiếp truyền thông điệp (message passing) so với cơ chế bộ nhớ được chia sẻ (shared memory)?
A. Qúa trình giao tiếp sử dụng cơ chế message passing không cần sự hỗ trợ của hệ điều hành trong khi shared memory lại cần.
B. Các tiến trình giao tiếp qua cơ chế message passing nhanh hơn khi giao tiếp qua cơ chế shared memory.
C. Qúa trình khởi tạo của cơ chế message passing đơn giản hơn shared memory.
Answer key: C. Qúa trình khởi tạo của cơ chế message passing đơn giản hơn shared memory.
Câu 3: Vấn đề nào sau đây có thể xảy ra khi thực hiện cơ chế giao tiếp shared memory?
A. Các tiến trình cần phải nhờ sự hỗ trợ của hệ điều hành để thực hiện quá trình giao tiếp.
B. Qúa trình các tiến trình truy cập vùng nhớ dùng chung có thể làm dữ liệu bị xung đột
C. Bộ nhớ dùng chung không đủ lớn để chứa dữ liệu của cả 2 tiến trình
D. Các tiến trình gặp khó khăn trong việc truy cập bộ nhớ dùng chung.
Answer key: B. Qúa trình các tiến trình truy cập vùng nhớ dùng chung có thể làm dữ liệu bị xung đột
VII. Tiểu trình:
1. Tổng quan về tiểu trình:
- Tiểu trình là một đơn vị cơ bản sử dụng CPU gồm:
+ Thread ID, PC, Registers, Stack và chia sẻ chung code, data, resources (files).
- Các tiểu trình có thể dùng chung biến toàn cục với nhau.  Vì các tiểu trình chia sẻ vùng Data, mà vùng Data Section chính là khu vực chứa biến toàn cục.
- Lợi ích của tiến trình đa luồng:
+ Đáp ứng nhanh: Cho phép chương trình tiếp tục thực thi khi một bộ phần bị khóa hoặc một hoạt động dài.
+ Chia sẻ tài nguyên: dễ dàng và tiết kiệm không gian nhớ.
+ Kinh tế: tạo và chuyển ngữ cảnh nhanh hơn tiến trình.
. Ví dụ: Trong Solaris 2, tạo process chậm hơn 30 lần, chuyển chậm hơn 5 lần so với thread.
+ Khả năng mở rộng: có khả năng thực thi song song trên nhiều lõi xử lý.
- Thực thi đồng thời: chỉ cần có single core, trong thời gian denta t thì thực thi đồng thời t1, t2, t3, t4,...
+ Nhiều công việc được phép thực thi đồng thời.
+ Trên hệ thống đơn bộ xử lý, bộ định thời được thiết kế để tạo ra cảm giác các công việc được thực thi song song nhưng thực tế chỉ có 1 công việc được thực thi tại một thời điểm.
- Thực thi song song: nhiều core CPU
+ Thực thi nhiều công việc song song với nhau bằng cách sử dụng nhiều lõi xử lý.
- Phân loại tiểu trình:
+ Tiểu trình người dùng:
. Thực thi các đoạn mã trong chương trình người dùng.
. Được quản lý mà không cần sự hỗ trợ từ hạt nhân.
+ Tiểu trình hạt nhân:
. Thực thi các thao tác hệ thống (thông qua system call).
. Được hỗ trợ và quản lý trực tiếp bởi hệ điều hành.
--- QUIZ ---
Câu 1: Các tiểu trình dùng chung và đùng riêng:
- Dùng chung: data, files, code.
- Dùng riêng: register, stack.
Câu 2: Chọn phát biểu đúng khi nói về tiểu trình?
A. Các tiểu trình có thể sử dụng chung biến cục bộ với nhau.
B. Mỗi tiến trình chỉ có thể tạo ra một tiểu trình.
C. Tiểu trình có thể được tạo và chuyển ngữ nhanh gấp nhiều lần so với tiến trình.
D. Các tiểu trình có thể được quản lý thông qua PCB của tiểu trình.
Answer key: C. Tiểu trình có thể được tạo và chuyển ngữ nhanh gấp nhiều lần so với tiến trình.
Câu 3: Ý nào sau đây KHÔNG phải là lợi ích của tiến trình đa luồng>
A. Các tiểu trình có thể tiết kiệm được không gian nhớ nhờ chia sẻ code, data, files.
B. Các tiểu trình có thể được thực thi trên nhiều lõi xử lý khác nhau.
C. Việc tạo và chuyển ngữ ảnh giữa các tiểu trình diễn ra nhanh hơn so với tiến trình.
D. Các tiểu trình có thể chia sẻ dữ liệu trong các thanh ghi để gia tăng hiệu quả công việc.
E. Tiến trình vẫn có thể thực thi kể cả khi một tiểu trình bị khóa.
Answer key: D. Các tiểu trình có thể chia sẻ dữ liệu trong các thanh ghi để gia tăng hiệu quả công việc.
2. Các mô hình đa tiểu trình:
- Nhiều - Một (Many-to-One)
- Một - Một (One-to-One)
- Nhiều - Nhiều (Many-to-Many)
- Mô hình Nhiều - Một (Many-to-One)
+ Nhiều tiến trình người dùng được ánh xạ đến một tiểu trình hạt nhân.
